{"version":3,"sources":["index.js"],"names":["App","state","list","radius","rotate","easeOut","angle","top","offset","net","result","spinning","topPosition","num","topSpot","degreesOff","Math","PI","_this","setState","spin","randomSpin","floor","random","setTimeout","getResult","_this$state","netRotation","travel","count","length","reset","this","renderWheel","numOptions","arcSize","i","text","renderSector","getColor","index","start","arc","color","canvas","document","getElementById","ctx","getContext","x","width","y","height","startAngle","endAngle","baseSize","textRadius","beginPath","lineWidth","strokeStyle","font","fillStyle","stroke","save","translate","cos","sin","fillText","measureText","restore","r","g","b","concat","react__WEBPACK_IMPORTED_MODULE_4___default","a","createElement","className","id","style","WebkitTransform","WebkitTransition","type","onClick","class","React","Component","rootElement","ReactDOM","render"],"mappings":"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","file":"static/js/main.54a6212e.chunk.js","sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport \"./styles.css\";\n\nclass App extends React.Component {\n  state = {\n    list: [\n      \"0\",\n      \"+100\",\n      \"-100\",\n      \"+200\",\n      \"-250\",\n      \"+300\",\n      \"+500\",\n      \"-500\",\n      \"+1000\"\n    ],\n\n    radius: 75, // PIXELS\n    rotate: 0, // DEGREES\n    easeOut: 0, // SECONDS\n    angle: 0, // RADIANS\n    top: null, // INDEX\n    offset: null, // RADIANS\n    net: null, // RADIANS\n    result: null, // INDEX\n    spinning: false\n  };\n\n  componentDidMount() {\n    // generate canvas wheel on load\n    this.renderWheel();\n  }\n\n  renderWheel() {\n    // determine number/size of sectors that need to created\n    let numOptions = this.state.list.length;\n    let arcSize = (2 * Math.PI) / numOptions;\n    this.setState({\n      angle: arcSize\n    });\n\n    // get index of starting position of selector\n    this.topPosition(numOptions, arcSize);\n\n    // dynamically generate sectors from state list\n    let angle = 0;\n    for (let i = 0; i < numOptions; i++) {\n      let text = this.state.list[i];\n      this.renderSector(i + 1, text, angle, arcSize, this.getColor());\n      angle += arcSize;\n    }\n  }\n\n  topPosition = (num, angle) => {\n    // set starting index and angle offset based on list length\n    // works upto 9 options\n    let topSpot = null;\n    let degreesOff = null;\n    if (num === 9) {\n      topSpot = 7;\n      degreesOff = Math.PI / 2 - angle * 2;\n    } else if (num === 8) {\n      topSpot = 6;\n      degreesOff = 0;\n    } else if (num <= 7 && num > 4) {\n      topSpot = num - 1;\n      degreesOff = Math.PI / 2 - angle;\n    } else if (num === 4) {\n      topSpot = num - 1;\n      degreesOff = 0;\n    } else if (num <= 3) {\n      topSpot = num;\n      degreesOff = Math.PI / 2;\n    }\n\n    this.setState({\n      top: topSpot - 1,\n      offset: degreesOff\n    });\n  };\n\n  renderSector(index, text, start, arc, color) {\n    // create canvas arc for each list element\n    let canvas = document.getElementById(\"wheel\");\n    let ctx = canvas.getContext(\"2d\");\n    let x = canvas.width / 2;\n    let y = canvas.height / 2;\n    let radius = this.state.radius;\n    let startAngle = start;\n    let endAngle = start + arc;\n    let angle = index * arc;\n    let baseSize = radius * 3.33;\n    let textRadius = baseSize - 150;\n\n    ctx.beginPath();\n    ctx.arc(x, y, radius, startAngle, endAngle, false);\n    ctx.lineWidth = radius * 2;\n    ctx.strokeStyle = color;\n\n    ctx.font = \"17px Arial\";\n    ctx.fillStyle = \"rgba\";\n    ctx.stroke();\n\n    ctx.save();\n    ctx.translate(\n      baseSize + Math.cos(angle - arc / 2) * textRadius,\n      baseSize + Math.sin(angle - arc / 2) * textRadius\n    );\n    ctx.rotate(angle - arc / 2 + Math.PI / 2);\n    ctx.fillText(text, -ctx.measureText(text).width / 2, 0);\n    ctx.restore();\n  }\n\n  getColor() {\n    // randomly generate rbg values for wheel sectors\n    let r = Math.floor(Math.random() * 255);\n    let g = Math.floor(Math.random() * 255);\n    let b = Math.floor(Math.random() * 255);\n    return `rgba(${r},${g},${b},0.4)`;\n  }\n\n  spin = () => {\n    // set random spin degree and ease out time\n    // set state variables to initiate animation\n    let randomSpin = Math.floor(Math.random() * 900) + 500;\n    this.setState({\n      rotate: randomSpin,\n      easeOut: 2,\n      spinning: true\n    });\n\n    // calcalute result after wheel stops spinning\n    setTimeout(() => {\n      this.getResult(randomSpin);\n    }, 2000);\n  };\n\n  getResult = (spin) => {\n    // find net rotation and add to offset angle\n    // repeat substraction of inner angle amount from total distance traversed\n    // use count as an index to find value of result from state list\n    const { angle, top, offset, list } = this.state;\n    let netRotation = ((spin % 360) * Math.PI) / 180; // RADIANS\n    let travel = netRotation + offset;\n    let count = top + 1;\n    while (travel > 0) {\n      travel = travel - angle;\n      count--;\n    }\n    let result;\n    if (count >= 0) {\n      result = count;\n    } else {\n      result = list.length + count;\n    }\n\n    // set state variable to display result\n    this.setState({\n      net: netRotation,\n      result: result\n    });\n  };\n\n  reset = () => {\n    // reset wheel and result\n    this.setState({\n      rotate: 0,\n      easeOut: 0,\n      result: null,\n      spinning: false\n    });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <h1> Spin The Wheel </h1>\n        <span id=\"selector\">&#9660;</span>\n        <canvas\n          id=\"wheel\"\n          width=\"500\"\n          height=\"500\"\n          style={{\n            WebkitTransform: `rotate(${this.state.rotate}deg)`,\n            WebkitTransition: `-webkit-transform ${this.state.easeOut}s ease-out`\n          }}\n        />\n\n        {this.state.spinning ? (\n          <button type=\"button\" id=\"reset\" onClick={this.reset}>\n            reset\n          </button>\n        ) : (\n          <button type=\"button\" id=\"spin\" onClick={this.spin}>\n            spin\n          </button>\n        )}\n        <div class=\"display\">\n          <span id=\"readout\">\n            YOU WON:{\"  \"}\n            <span id=\"result\">{this.state.list[this.state.result]}</span>\n          </span>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}